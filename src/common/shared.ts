/*
 * Copyright (C) 1997-2001 Id Software, Inc.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or (at
 * your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 *
 * See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
 * 02111-1307, USA.
 *
 * =======================================================================
 *
 * This is the main header file shared between client, renderer, server
 * and the game. Do NOT edit this file unless you know what you're
 * doing. Changes here may break the client <-> renderer <-> server
 * <-> game API, leading to problems with mods!
 *
 * =======================================================================
 */

/* angle indexes */
export const PITCH = 0                     /* up / down */
export const YAW = 1                       /* left / right */
export const ROLL = 2                      /* fall over */


/* per-level limits */
export const MAX_CLIENTS = 256             /* absolute limit */
export const MAX_EDICTS = 1024             /* must change protocol to increase more */
export const MAX_LIGHTSTYLES = 256
export const MAX_MODELS = 256              /* these are sent over the net as bytes */
export const MAX_SOUNDS = 256              /* so they cannot be blindly increased */
export const MAX_IMAGES = 256
export const MAX_ITEMS = 256
export const MAX_GENERAL = (MAX_CLIENTS * 2)       /* general config strings */

/* game print flags */
export const PRINT_LOW = 0                 /* pickup messages */
export const PRINT_MEDIUM = 1              /* death messages */
export const PRINT_HIGH = 2                /* critical messages */
export const PRINT_CHAT = 3                /* chat messages */

export const ERR_FATAL = 0                 /* exit the entire game with a popup window */
export const ERR_DROP = 1                  /* print to console and disconnect from game */
export const ERR_DISCONNECT = 2            /* don't kill server */

export const PRINT_ALL = 0
export const PRINT_DEVELOPER = 1           /* only print when "developer 1" */
export const PRINT_ALERT = 2

export const MAX_QPATH = 64                /* max length of a quake game pathname */

/*
 * ==========================================================
 *
 * CVARS (console variables)
 *
 * ==========================================================
 */

export const CVAR_ARCHIVE = 1     /* set to cause it to be saved to vars.rc */
export const CVAR_USERINFO = 2    /* added to userinfo  when changed */
export const CVAR_SERVERINFO = 4  /* added to serverinfo when changed */
export const CVAR_NOSET = 8       /* don't allow change from console at all, */
                                  /* but can be set from the command line */
export const CVAR_LATCH = 16      /* save changes until server restart */

/* nothing outside the Cvar_*() functions should modify these fields! */
export class cvar_t {
	name: string
	string: string
	latched_string: string /* for CVAR_LATCH vars */
	flags: number
	modified: boolean /* set each time the cvar is changed */
	/* Added by YQ2. Must be at the end to preserve ABI. */
	default_string: string

    constructor(n: string, v: string, f: number) {
        this.name = n
        this.string = v
        this.latched_string = null
        this.flags = f
        this.modified = true
        this.default_string = v
    }

    get int(): number {
        let v = parseInt(this.string, 10)
        if (isNaN(v)) return 0
        return v
    }

    get float(): number {
        let v = parseFloat(this.string)
        if (isNaN(v)) return 0
        return v
    }

    get bool(): boolean {
        let v = parseFloat(this.string)
        if (isNaN(v)) return this.string.length > 0
        return v != 0.0
    }
}

/*
 * ==============================================================
 *
 * COLLISION DETECTION
 *
 * ==============================================================
 */

/* lower bits are stronger, and will eat weaker brushes completely */
export const CONTENTS_SOLID = 1                /* an eye is never valid in a solid */
export const CONTENTS_WINDOW = 2               /* translucent, but not watery */
export const CONTENTS_AUX = 4
export const CONTENTS_LAVA = 8
export const CONTENTS_SLIME = 16
export const CONTENTS_WATER = 32
export const CONTENTS_MIST = 64
export const LAST_VISIBLE_CONTENTS = 64

/* remaining contents are non-visible, and don't eat brushes */
export const CONTENTS_AREAPORTAL = 0x8000

export const CONTENTS_PLAYERCLIP = 0x10000
export const CONTENTS_MONSTERCLIP = 0x20000

/* currents can be added to any other contents, and may be mixed */
export const CONTENTS_CURRENT_0 = 0x40000
export const CONTENTS_CURRENT_90 = 0x80000
export const CONTENTS_CURRENT_180 = 0x100000
export const CONTENTS_CURRENT_270 = 0x200000
export const CONTENTS_CURRENT_UP = 0x400000
export const CONTENTS_CURRENT_DOWN = 0x800000

export const CONTENTS_ORIGIN = 0x1000000           /* removed before bsping an entity */

export const CONTENTS_MONSTER = 0x2000000          /* should never be on a brush, only in game */
export const CONTENTS_DEADMONSTER = 0x4000000
export const CONTENTS_DETAIL = 0x8000000           /* brushes to be added after vis leafs */
export const CONTENTS_TRANSLUCENT = 0x10000000     /* auto set if any surface has trans */
export const CONTENTS_LADDER = 0x20000000

export const SURF_LIGHT = 0x1          /* value will hold the light strength */

export const SURF_SLICK = 0x2          /* effects game physics */

export const SURF_SKY = 0x4            /* don't draw, but add to skybox */
export const SURF_WARP = 0x8           /* turbulent water warp */
export const SURF_TRANS33 = 0x10
export const SURF_TRANS66 = 0x20
export const SURF_FLOWING = 0x40       /* scroll towards angle */
export const SURF_NODRAW = 0x80        /* don't bother referencing the texture */


/* content masks */
export const MASK_ALL = -1
export const MASK_SOLID = CONTENTS_SOLID | CONTENTS_WINDOW
export const MASK_PLAYERSOLID =
	CONTENTS_SOLID | CONTENTS_PLAYERCLIP |	
	CONTENTS_WINDOW | CONTENTS_MONSTER
export const MASK_DEADSOLID = CONTENTS_SOLID | CONTENTS_PLAYERCLIP | CONTENTS_WINDOW
export const MASK_MONSTERSOLID =
	CONTENTS_SOLID | CONTENTS_MONSTERCLIP |
	CONTENTS_WINDOW | CONTENTS_MONSTER
export const MASK_WATER = CONTENTS_WATER | CONTENTS_LAVA | CONTENTS_SLIME
export const MASK_OPAQUE = CONTENTS_SOLID | CONTENTS_SLIME | CONTENTS_LAVA
export const MASK_SHOT =
	CONTENTS_SOLID | CONTENTS_MONSTER | CONTENTS_WINDOW |
	CONTENTS_DEADMONSTER
export const MASK_CURRENT =
	CONTENTS_CURRENT_0 | CONTENTS_CURRENT_90 |
	CONTENTS_CURRENT_180 | CONTENTS_CURRENT_270 |
	CONTENTS_CURRENT_UP |
	CONTENTS_CURRENT_DOWN

/* gi.BoxEdicts() can return a list of either solid or trigger entities */
export const AREA_SOLID = 1
export const AREA_TRIGGERS = 2


/* plane_t structure */
export class cplane_t {
	normal = [0,0,0]
	dist = 0
	type = 0 /* for fast side tests */
	signbits = 0 /* signx + (signy<<1) + (signz<<2) */
	// byte pad[2];

	copy(other: cplane_t) {
		this.normal[0] = other.normal[0]
		this.normal[1] = other.normal[1]
		this.normal[2] = other.normal[2]
		this.dist = other.dist
		this.type = other.type
		this.signbits = other.signbits
	}
}

export class cmodel_t {
	mins = [0,0,0]
	maxs = [0,0,0]
	origin = [0,0,0] /* for sounds or lights */
	headnode = 0;
}

export class csurface_t {
	name: string = ""
	flags = 0; /* SURF_* */
	value = 0; /* unused */
}


export class mapsurface_t {  /* used internally due to name len probs */
	c = new csurface_t()
	rname: string = ""
}


/* pmove_state_t is the information necessary for client side movement */
/* prediction */
export enum pmtype_t {
	/* can accelerate and turn */
	PM_NORMAL,
	PM_SPECTATOR,
	/* no acceleration or turning */
	PM_DEAD,
	PM_GIB, /* different bounding box */
	PM_FREEZE
}

/* pmove->pm_flags */
export const PMF_DUCKED = 1
export const PMF_JUMP_HELD = 2
export const PMF_ON_GROUND = 4
export const PMF_TIME_WATERJUMP = 8    /* pm_time is waterjump */
export const PMF_TIME_LAND = 16        /* pm_time is time before rejump */
export const PMF_TIME_TELEPORT = 32    /* pm_time is non-moving time */
export const PMF_NO_PREDICTION = 64    /* temporarily disables prediction (used for grappling hook) */


/* this structure needs to be communicated bit-accurate/
 * from the server to the client to guarantee that
 * prediction stays in sync, so no floats are used.
 * if any part of the game code modifies this struct, it
 * will result in a prediction error of some degree. */
export class pmove_state_t {
	pm_type = pmtype_t.PM_NORMAL

	origin = [0,0,0]            /* 12.3 */
	velocity = [0,0,0]          /* 12.3 */
	pm_flags = 0                /* ducked, jump_held, etc */
	pm_time = 0                 /* each unit = 8 ms */
	gravity = 0
	delta_angles = [0,0,0]      /* add to command angles to get view direction
								 * changed by spawns, rotating objects, and teleporters */

    copy(other: pmove_state_t) {
        this.pm_type = other.pm_type
        for (let i = 0; i < 3; i++) {
            this.origin[i] = other.origin[i]
            this.velocity[i] = other.velocity[i]
            this.delta_angles[i] = other.delta_angles[i]
        }
        this.pm_flags = other.pm_flags
        this.pm_time = other.pm_time
        this.gravity = other.gravity
    }
}

/* button bits */
export const BUTTON_ATTACK = 1
export const BUTTON_USE = 2
export const BUTTON_ANY = 128 /* any key whatsoever */

/* usercmd_t is sent to the server each client frame */
export class usercmd_t {
	msec: number = 0
	buttons: number = 0
	angles = [0,0,0]
    forwardmove: number = 0
    sidemove: number = 0
    upmove: number = 0
	impulse: number = 0           /* remove? */
	lightlevel: number = 0        /* light level the player is standing on */

    copy(other: usercmd_t) {
        this.msec = other.msec
        this.buttons = other.buttons
        for (let i = 0; i < 3; i++) {
            this.angles[i] = other.angles[i]
        }
        this.forwardmove = other.forwardmove
        this.sidemove = other.sidemove
        this.upmove = other.upmove
        this.impulse = other.impulse
        this.lightlevel = other.lightlevel
    }
}

/* a trace is returned when a box is swept through the world */
export class trace_t {
	allsolid = false      /* if true, plane is not valid */
	startsolid = false    /* if true, the initial point was in a solid area */
	fraction = 0         /* time completed, 1.0 = didn't hit anything */
	endpos = [0,0,0]          /* final position */
	plane = new cplane_t()         /* surface normal at impact */
	surface: csurface_t = null    /* surface hit */
	contents = 0           /* contents on other side of surface hit */
	ent: object = null    /* not set by CM_*() functions */
} ;


export const MAXTOUCH = 32
export class pmove_t {
	/* state (in / out) */
	s = new pmove_state_t()

	/* command (in) */
	cmd = new usercmd_t()
	snapinitial = false           /* if s has been changed outside pmove */

	/* results (out) */
	numtouch = 0
	// struct edict_s *touchents[MAXTOUCH];

	viewangles = [0,0,0]              /* clamped */
	viewheight = 0

	/* bounding box size */
    mins = [0,0,0]
    maxs = [0,0,0]

	groundentity: object = null
	watertype = 0
	waterlevel = 0

	/* callbacks to test the world */
	trace: (start: number[], staminsrt: number[], maxs: number[], end: number[]) => trace_t
	pointcontents: (point: number[]) => number
}

/* entity_state_t->effects
 * Effects are things handled on the client side (lights, particles,
 * frame animations)  that happen constantly on the given entity.
 * An entity that has effects will be sent to the client even if
 * it has a zero index model. */
export const EF_ROTATE = 0x00000001                /* rotate (bonus items) */
export const EF_GIB = 0x00000002                   /* leave a trail */
export const EF_BLASTER = 0x00000008               /* redlight + trail */
export const EF_ROCKET = 0x00000010                /* redlight + trail */
export const EF_GRENADE = 0x00000020
export const EF_HYPERBLASTER = 0x00000040
export const EF_BFG = 0x00000080
export const EF_COLOR_SHELL = 0x00000100
export const EF_POWERSCREEN = 0x00000200
export const EF_ANIM01 = 0x00000400                /* automatically cycle between frames 0 and 1 at 2 hz */
export const EF_ANIM23 = 0x00000800                /* automatically cycle between frames 2 and 3 at 2 hz */
export const EF_ANIM_ALL = 0x00001000              /* automatically cycle through all frames at 2hz */
export const EF_ANIM_ALLFAST = 0x00002000          /* automatically cycle through all frames at 10hz */
export const EF_FLIES = 0x00004000
export const EF_QUAD = 0x00008000
export const EF_PENT = 0x00010000
export const EF_TELEPORTER = 0x00020000            /* particle fountain */
export const EF_FLAG1 = 0x00040000
export const EF_FLAG2 = 0x00080000
export const EF_IONRIPPER = 0x00100000
export const EF_GREENGIB = 0x00200000
export const EF_BLUEHYPERBLASTER = 0x00400000
export const EF_SPINNINGLIGHTS = 0x00800000
export const EF_PLASMA = 0x01000000
export const EF_TRAP = 0x02000000
export const EF_TRACKER = 0x04000000
export const EF_DOUBLE = 0x08000000
export const EF_SPHERETRANS = 0x10000000
export const EF_TAGTRAIL = 0x20000000
export const EF_HALF_DAMAGE = 0x40000000
export const EF_TRACKERTRAIL = 0x80000000

/* entity_state_t->renderfx flags */
export const RF_MINLIGHT = 1               /* allways have some light (viewmodel) */
export const RF_VIEWERMODEL = 2            /* don't draw through eyes, only mirrors */
export const RF_WEAPONMODEL = 4            /* only draw through eyes */
export const RF_FULLBRIGHT = 8             /* allways draw full intensity */
export const RF_DEPTHHACK = 16             /* for view weapon Z crunching */
export const RF_TRANSLUCENT = 32
export const RF_FRAMELERP = 64
export const RF_BEAM = 128
export const RF_CUSTOMSKIN = 256           /* skin is an index in image_precache */
export const RF_GLOW = 512                 /* pulse lighting for bonus items */
export const RF_SHELL_RED = 1024
export const RF_SHELL_GREEN = 2048
export const RF_SHELL_BLUE = 4096
export const RF_NOSHADOW = 8192        /* don't draw a shadow */
export const RF_IR_VISIBLE = 0x00008000            /* 32768 */
export const RF_SHELL_DOUBLE = 0x00010000          /* 65536 */
export const RF_SHELL_HALF_DAM = 0x00020000
export const RF_USE_DISGUISE = 0x00040000

/* player_state_t->refdef flags */
export const RDF_UNDERWATER = 1            /* warp the screen as apropriate */
export const RDF_NOWORLDMODEL = 2          /* used for player configuration screen */
export const RDF_IRGOGGLES = 4
export const RDF_UVGOGGLES = 8

/* muzzle flashes / player effects */
export const MZ_BLASTER = 0
export const MZ_MACHINEGUN = 1
export const MZ_SHOTGUN = 2
export const MZ_CHAINGUN1 = 3
export const MZ_CHAINGUN2 = 4
export const MZ_CHAINGUN3 = 5
export const MZ_RAILGUN = 6
export const MZ_ROCKET = 7
export const MZ_GRENADE = 8
export const MZ_LOGIN = 9
export const MZ_LOGOUT = 10
export const MZ_RESPAWN = 11
export const MZ_BFG = 12
export const MZ_SSHOTGUN = 13
export const MZ_HYPERBLASTER = 14
export const MZ_ITEMRESPAWN = 15
export const MZ_IONRIPPER = 16
export const MZ_BLUEHYPERBLASTER = 17
export const MZ_PHALANX = 18
export const MZ_SILENCED = 128             /* bit flag ORed with one of the above numbers */
export const MZ_ETF_RIFLE = 30
export const MZ_UNUSED = 31
export const MZ_SHOTGUN2 = 32
export const MZ_HEATBEAM = 33
export const MZ_BLASTER2 = 34
export const MZ_TRACKER = 35
export const MZ_NUKE1 = 36
export const MZ_NUKE2 = 37
export const MZ_NUKE4 = 38
export const MZ_NUKE8 = 39

/* monster muzzle flashes */
export const MZ2_TANK_BLASTER_1 = 1
export const MZ2_TANK_BLASTER_2 = 2
export const MZ2_TANK_BLASTER_3 = 3
export const MZ2_TANK_MACHINEGUN_1 = 4
export const MZ2_TANK_MACHINEGUN_2 = 5
export const MZ2_TANK_MACHINEGUN_3 = 6
export const MZ2_TANK_MACHINEGUN_4 = 7
export const MZ2_TANK_MACHINEGUN_5 = 8
export const MZ2_TANK_MACHINEGUN_6 = 9
export const MZ2_TANK_MACHINEGUN_7 = 10
export const MZ2_TANK_MACHINEGUN_8 = 11
export const MZ2_TANK_MACHINEGUN_9 = 12
export const MZ2_TANK_MACHINEGUN_10 = 13
export const MZ2_TANK_MACHINEGUN_11 = 14
export const MZ2_TANK_MACHINEGUN_12 = 15
export const MZ2_TANK_MACHINEGUN_13 = 16
export const MZ2_TANK_MACHINEGUN_14 = 17
export const MZ2_TANK_MACHINEGUN_15 = 18
export const MZ2_TANK_MACHINEGUN_16 = 19
export const MZ2_TANK_MACHINEGUN_17 = 20
export const MZ2_TANK_MACHINEGUN_18 = 21
export const MZ2_TANK_MACHINEGUN_19 = 22
export const MZ2_TANK_ROCKET_1 = 23
export const MZ2_TANK_ROCKET_2 = 24
export const MZ2_TANK_ROCKET_3 = 25

export const MZ2_INFANTRY_MACHINEGUN_1 = 26
export const MZ2_INFANTRY_MACHINEGUN_2 = 27
export const MZ2_INFANTRY_MACHINEGUN_3 = 28
export const MZ2_INFANTRY_MACHINEGUN_4 = 29
export const MZ2_INFANTRY_MACHINEGUN_5 = 30
export const MZ2_INFANTRY_MACHINEGUN_6 = 31
export const MZ2_INFANTRY_MACHINEGUN_7 = 32
export const MZ2_INFANTRY_MACHINEGUN_8 = 33
export const MZ2_INFANTRY_MACHINEGUN_9 = 34
export const MZ2_INFANTRY_MACHINEGUN_10 = 35
export const MZ2_INFANTRY_MACHINEGUN_11 = 36
export const MZ2_INFANTRY_MACHINEGUN_12 = 37
export const MZ2_INFANTRY_MACHINEGUN_13 = 38

export const MZ2_SOLDIER_BLASTER_1 = 39
export const MZ2_SOLDIER_BLASTER_2 = 40
export const MZ2_SOLDIER_SHOTGUN_1 = 41
export const MZ2_SOLDIER_SHOTGUN_2 = 42
export const MZ2_SOLDIER_MACHINEGUN_1 = 43
export const MZ2_SOLDIER_MACHINEGUN_2 = 44

export const MZ2_GUNNER_MACHINEGUN_1 = 45
export const MZ2_GUNNER_MACHINEGUN_2 = 46
export const MZ2_GUNNER_MACHINEGUN_3 = 47
export const MZ2_GUNNER_MACHINEGUN_4 = 48
export const MZ2_GUNNER_MACHINEGUN_5 = 49
export const MZ2_GUNNER_MACHINEGUN_6 = 50
export const MZ2_GUNNER_MACHINEGUN_7 = 51
export const MZ2_GUNNER_MACHINEGUN_8 = 52
export const MZ2_GUNNER_GRENADE_1 = 53
export const MZ2_GUNNER_GRENADE_2 = 54
export const MZ2_GUNNER_GRENADE_3 = 55
export const MZ2_GUNNER_GRENADE_4 = 56

export const MZ2_CHICK_ROCKET_1 = 57

export const MZ2_FLYER_BLASTER_1 = 58
export const MZ2_FLYER_BLASTER_2 = 59

export const MZ2_MEDIC_BLASTER_1 = 60

export const MZ2_GLADIATOR_RAILGUN_1 = 61

export const MZ2_HOVER_BLASTER_1 = 62

export const MZ2_ACTOR_MACHINEGUN_1 = 63

export const MZ2_SUPERTANK_MACHINEGUN_1 = 64
export const MZ2_SUPERTANK_MACHINEGUN_2 = 65
export const MZ2_SUPERTANK_MACHINEGUN_3 = 66
export const MZ2_SUPERTANK_MACHINEGUN_4 = 67
export const MZ2_SUPERTANK_MACHINEGUN_5 = 68
export const MZ2_SUPERTANK_MACHINEGUN_6 = 69
export const MZ2_SUPERTANK_ROCKET_1 = 70
export const MZ2_SUPERTANK_ROCKET_2 = 71
export const MZ2_SUPERTANK_ROCKET_3 = 72

export const MZ2_BOSS2_MACHINEGUN_L1 = 73
export const MZ2_BOSS2_MACHINEGUN_L2 = 74
export const MZ2_BOSS2_MACHINEGUN_L3 = 75
export const MZ2_BOSS2_MACHINEGUN_L4 = 76
export const MZ2_BOSS2_MACHINEGUN_L5 = 77
export const MZ2_BOSS2_ROCKET_1 = 78
export const MZ2_BOSS2_ROCKET_2 = 79
export const MZ2_BOSS2_ROCKET_3 = 80
export const MZ2_BOSS2_ROCKET_4 = 81

export const MZ2_FLOAT_BLASTER_1 = 82

export const MZ2_SOLDIER_BLASTER_3 = 83
export const MZ2_SOLDIER_SHOTGUN_3 = 84
export const MZ2_SOLDIER_MACHINEGUN_3 = 85
export const MZ2_SOLDIER_BLASTER_4 = 86
export const MZ2_SOLDIER_SHOTGUN_4 = 87
export const MZ2_SOLDIER_MACHINEGUN_4 = 88
export const MZ2_SOLDIER_BLASTER_5 = 89
export const MZ2_SOLDIER_SHOTGUN_5 = 90
export const MZ2_SOLDIER_MACHINEGUN_5 = 91
export const MZ2_SOLDIER_BLASTER_6 = 92
export const MZ2_SOLDIER_SHOTGUN_6 = 93
export const MZ2_SOLDIER_MACHINEGUN_6 = 94
export const MZ2_SOLDIER_BLASTER_7 = 95
export const MZ2_SOLDIER_SHOTGUN_7 = 96
export const MZ2_SOLDIER_MACHINEGUN_7 = 97
export const MZ2_SOLDIER_BLASTER_8 = 98
export const MZ2_SOLDIER_SHOTGUN_8 = 99
export const MZ2_SOLDIER_MACHINEGUN_8 = 100

export const MZ2_MAKRON_BFG = 101
export const MZ2_MAKRON_BLASTER_1 = 102
export const MZ2_MAKRON_BLASTER_2 = 103
export const MZ2_MAKRON_BLASTER_3 = 104
export const MZ2_MAKRON_BLASTER_4 = 105
export const MZ2_MAKRON_BLASTER_5 = 106
export const MZ2_MAKRON_BLASTER_6 = 107
export const MZ2_MAKRON_BLASTER_7 = 108
export const MZ2_MAKRON_BLASTER_8 = 109
export const MZ2_MAKRON_BLASTER_9 = 110
export const MZ2_MAKRON_BLASTER_10 = 111
export const MZ2_MAKRON_BLASTER_11 = 112
export const MZ2_MAKRON_BLASTER_12 = 113
export const MZ2_MAKRON_BLASTER_13 = 114
export const MZ2_MAKRON_BLASTER_14 = 115
export const MZ2_MAKRON_BLASTER_15 = 116
export const MZ2_MAKRON_BLASTER_16 = 117
export const MZ2_MAKRON_BLASTER_17 = 118
export const MZ2_MAKRON_RAILGUN_1 = 119
export const MZ2_JORG_MACHINEGUN_L1 = 120
export const MZ2_JORG_MACHINEGUN_L2 = 121
export const MZ2_JORG_MACHINEGUN_L3 = 122
export const MZ2_JORG_MACHINEGUN_L4 = 123
export const MZ2_JORG_MACHINEGUN_L5 = 124
export const MZ2_JORG_MACHINEGUN_L6 = 125
export const MZ2_JORG_MACHINEGUN_R1 = 126
export const MZ2_JORG_MACHINEGUN_R2 = 127
export const MZ2_JORG_MACHINEGUN_R3 = 128
export const MZ2_JORG_MACHINEGUN_R4 = 129
export const MZ2_JORG_MACHINEGUN_R5 = 130
export const MZ2_JORG_MACHINEGUN_R6 = 131
export const MZ2_JORG_BFG_1 = 132
export const MZ2_BOSS2_MACHINEGUN_R1 = 133
export const MZ2_BOSS2_MACHINEGUN_R2 = 134
export const MZ2_BOSS2_MACHINEGUN_R3 = 135
export const MZ2_BOSS2_MACHINEGUN_R4 = 136
export const MZ2_BOSS2_MACHINEGUN_R5 = 137

export const MZ2_CARRIER_MACHINEGUN_L1 = 138
export const MZ2_CARRIER_MACHINEGUN_R1 = 139
export const MZ2_CARRIER_GRENADE = 140
export const MZ2_TURRET_MACHINEGUN = 141
export const MZ2_TURRET_ROCKET = 142
export const MZ2_TURRET_BLASTER = 143
export const MZ2_STALKER_BLASTER = 144
export const MZ2_DAEDALUS_BLASTER = 145
export const MZ2_MEDIC_BLASTER_2 = 146
export const MZ2_CARRIER_RAILGUN = 147
export const MZ2_WIDOW_DISRUPTOR = 148
export const MZ2_WIDOW_BLASTER = 149
export const MZ2_WIDOW_RAIL = 150
export const MZ2_WIDOW_PLASMABEAM = 151
export const MZ2_CARRIER_MACHINEGUN_L2 = 152
export const MZ2_CARRIER_MACHINEGUN_R2 = 153
export const MZ2_WIDOW_RAIL_LEFT = 154
export const MZ2_WIDOW_RAIL_RIGHT = 155
export const MZ2_WIDOW_BLASTER_SWEEP1 = 156
export const MZ2_WIDOW_BLASTER_SWEEP2 = 157
export const MZ2_WIDOW_BLASTER_SWEEP3 = 158
export const MZ2_WIDOW_BLASTER_SWEEP4 = 159
export const MZ2_WIDOW_BLASTER_SWEEP5 = 160
export const MZ2_WIDOW_BLASTER_SWEEP6 = 161
export const MZ2_WIDOW_BLASTER_SWEEP7 = 162
export const MZ2_WIDOW_BLASTER_SWEEP8 = 163
export const MZ2_WIDOW_BLASTER_SWEEP9 = 164
export const MZ2_WIDOW_BLASTER_100 = 165
export const MZ2_WIDOW_BLASTER_90 = 166
export const MZ2_WIDOW_BLASTER_80 = 167
export const MZ2_WIDOW_BLASTER_70 = 168
export const MZ2_WIDOW_BLASTER_60 = 169
export const MZ2_WIDOW_BLASTER_50 = 170
export const MZ2_WIDOW_BLASTER_40 = 171
export const MZ2_WIDOW_BLASTER_30 = 172
export const MZ2_WIDOW_BLASTER_20 = 173
export const MZ2_WIDOW_BLASTER_10 = 174
export const MZ2_WIDOW_BLASTER_0 = 175
export const MZ2_WIDOW_BLASTER_10L = 176
export const MZ2_WIDOW_BLASTER_20L = 177
export const MZ2_WIDOW_BLASTER_30L = 178
export const MZ2_WIDOW_BLASTER_40L = 179
export const MZ2_WIDOW_BLASTER_50L = 180
export const MZ2_WIDOW_BLASTER_60L = 181
export const MZ2_WIDOW_BLASTER_70L = 182
export const MZ2_WIDOW_RUN_1 = 183
export const MZ2_WIDOW_RUN_2 = 184
export const MZ2_WIDOW_RUN_3 = 185
export const MZ2_WIDOW_RUN_4 = 186
export const MZ2_WIDOW_RUN_5 = 187
export const MZ2_WIDOW_RUN_6 = 188
export const MZ2_WIDOW_RUN_7 = 189
export const MZ2_WIDOW_RUN_8 = 190
export const MZ2_CARRIER_ROCKET_1 = 191
export const MZ2_CARRIER_ROCKET_2 = 192
export const MZ2_CARRIER_ROCKET_3 = 193
export const MZ2_CARRIER_ROCKET_4 = 194
export const MZ2_WIDOW2_BEAMER_1 = 195
export const MZ2_WIDOW2_BEAMER_2 = 196
export const MZ2_WIDOW2_BEAMER_3 = 197
export const MZ2_WIDOW2_BEAMER_4 = 198
export const MZ2_WIDOW2_BEAMER_5 = 199
export const MZ2_WIDOW2_BEAM_SWEEP_1 = 200
export const MZ2_WIDOW2_BEAM_SWEEP_2 = 201
export const MZ2_WIDOW2_BEAM_SWEEP_3 = 202
export const MZ2_WIDOW2_BEAM_SWEEP_4 = 203
export const MZ2_WIDOW2_BEAM_SWEEP_5 = 204
export const MZ2_WIDOW2_BEAM_SWEEP_6 = 205
export const MZ2_WIDOW2_BEAM_SWEEP_7 = 206
export const MZ2_WIDOW2_BEAM_SWEEP_8 = 207
export const MZ2_WIDOW2_BEAM_SWEEP_9 = 208
export const MZ2_WIDOW2_BEAM_SWEEP_10 = 209
export const MZ2_WIDOW2_BEAM_SWEEP_11 = 210

/* Temp entity events are for things that happen
 * at a location seperate from any existing entity.
 * Temporary entity messages are explicitly constructed
 * and broadcast. */
export enum temp_event_t {
	TE_GUNSHOT = 0,
	TE_BLOOD,
	TE_BLASTER,
	TE_RAILTRAIL,
	TE_SHOTGUN,
	TE_EXPLOSION1,
	TE_EXPLOSION2,
	TE_ROCKET_EXPLOSION,
	TE_GRENADE_EXPLOSION,
	TE_SPARKS,
	TE_SPLASH,
	TE_BUBBLETRAIL,
	TE_SCREEN_SPARKS,
	TE_SHIELD_SPARKS,
	TE_BULLET_SPARKS,
	TE_LASER_SPARKS,
	TE_PARASITE_ATTACK,
	TE_ROCKET_EXPLOSION_WATER,
	TE_GRENADE_EXPLOSION_WATER,
	TE_MEDIC_CABLE_ATTACK,
	TE_BFG_EXPLOSION,
	TE_BFG_BIGEXPLOSION,
	TE_BOSSTPORT,           /* used as '22' in a map, so DON'T RENUMBER!!! */
	TE_BFG_LASER,
	TE_GRAPPLE_CABLE,
	TE_WELDING_SPARKS,
	TE_GREENBLOOD,
	TE_BLUEHYPERBLASTER,
	TE_PLASMA_EXPLOSION,
	TE_TUNNEL_SPARKS,
	TE_BLASTER2,
	TE_RAILTRAIL2,
	TE_FLAME,
	TE_LIGHTNING,
	TE_DEBUGTRAIL,
	TE_PLAIN_EXPLOSION,
	TE_FLASHLIGHT,
	TE_FORCEWALL,
	TE_HEATBEAM,
	TE_MONSTER_HEATBEAM,
	TE_STEAM,
	TE_BUBBLETRAIL2,
	TE_MOREBLOOD,
	TE_HEATBEAM_SPARKS,
	TE_HEATBEAM_STEAM,
	TE_CHAINFIST_SMOKE,
	TE_ELECTRIC_SPARKS,
	TE_TRACKER_EXPLOSION,
	TE_TELEPORT_EFFECT,
	TE_DBALL_GOAL,
	TE_WIDOWBEAMOUT,
	TE_NUKEBLAST,
	TE_WIDOWSPLASH,
	TE_EXPLOSION1_BIG,
	TE_EXPLOSION1_NP,
	TE_FLECHETTE
}


/* player_state->stats[] indexes */
export const STAT_HEALTH_ICON = 0
export const STAT_HEALTH = 1
export const STAT_AMMO_ICON = 2
export const STAT_AMMO = 3
export const STAT_ARMOR_ICON = 4
export const STAT_ARMOR = 5
export const STAT_SELECTED_ICON = 6
export const STAT_PICKUP_ICON = 7
export const STAT_PICKUP_STRING = 8
export const STAT_TIMER_ICON = 9
export const STAT_TIMER = 10
export const STAT_HELPICON = 11
export const STAT_SELECTED_ITEM = 12
export const STAT_LAYOUTS = 13
export const STAT_FRAGS = 14
export const STAT_FLASHES = 15                 /* cleared each frame, 1 = health, 2 = armor */
export const STAT_CHASE = 16
export const STAT_SPECTATOR = 17

export const MAX_STATS = 32

/*
 * ==========================================================
 *
 * ELEMENTS COMMUNICATED ACROSS THE NET
 *
 * ==========================================================
 */

export function ANGLE2SHORT(x: number): number {
    return (~~((x) * 65536 / 360) & 65535)
}
export function SHORT2ANGLE(x: number): number {
    return ((x) * (360.0 / 65536))
}

/* config strings are a general means of communication from
 * the server to all connected clients. Each config string
 * can be at most MAX_QPATH characters. */
export const CS_NAME = 0
export const CS_CDTRACK = 1
export const CS_SKY = 2
export const CS_SKYAXIS = 3                /* %f %f %f format */
export const CS_SKYROTATE = 4
export const CS_STATUSBAR = 5              /* display program string */

export const CS_AIRACCEL = 29              /* air acceleration control */
export const CS_MAXCLIENTS = 30
export const CS_MAPCHECKSUM = 31           /* for catching cheater maps */

export const CS_MODELS = 32
export const CS_SOUNDS = (CS_MODELS + MAX_MODELS)
export const CS_IMAGES = (CS_SOUNDS + MAX_SOUNDS)
export const CS_LIGHTS = (CS_IMAGES + MAX_IMAGES)
export const CS_ITEMS = (CS_LIGHTS + MAX_LIGHTSTYLES)
export const CS_PLAYERSKINS = (CS_ITEMS + MAX_ITEMS)
export const CS_GENERAL = (CS_PLAYERSKINS + MAX_CLIENTS)
export const MAX_CONFIGSTRINGS = (CS_GENERAL + MAX_GENERAL)

/* ============================================== */

/* entity_state_t->event values
 * entity events are for effects that take place reletive
 * to an existing entities origin.  Very network efficient.
 * All muzzle flashes really should be converted to events... */
export enum entity_event_t {
	EV_NONE,
	EV_ITEM_RESPAWN,
	EV_FOOTSTEP,
	EV_FALLSHORT,
	EV_FALL,
	EV_FALLFAR,
	EV_PLAYER_TELEPORT,
	EV_OTHER_TELEPORT
}

/* entity_state_t is the information conveyed from the server
 * in an update message about entities that the client will
 * need to render in some way */
export class entity_state_t {
	number: number = 0             /* edict index */

	origin: number[] = [0,0,0]
	angles: number[] = [0,0,0]
	old_origin: number[] = [0,0,0]      /* for lerping */
	modelindex: number = 0
	modelindex2: number = 0
    modelindex3: number = 0
    modelindex4: number = 0      /* weapons, CTF flags, etc */
	frame: number = 0
	skinnum: number = 0
	effects: number = 0
	renderfx: number = 0
	solid: number = 0              /* for client side prediction, 8*(bits 0-4) is x/y radius */
							/* 8*(bits 5-9) is z down distance, 8(bits10-15) is z up */
							/* gi.linkentity sets this properly */
	sound: number = 0              /* for looping sounds, to guarantee shutoff */
	event: number = 0              /* impulse events -- muzzle flashes, footsteps, etc */
							/* events only go out for a single frame, they */
							/* are automatically cleared each frame */

    copy(other: entity_state_t) {
        this.number = other.number
        for (let i = 0; i < 3; i++) {
            this.origin[i] = other.origin[i]
            this.angles[i] = other.angles[i]
            this.old_origin[i] = other.old_origin[i]
        }
        this.modelindex = other.modelindex
        this.modelindex2 = other.modelindex2
        this.modelindex3 = other.modelindex3
        this.modelindex4 = other.modelindex4
        this.frame = other.frame
        this.skinnum = other.skinnum
        this.effects = other.effects
        this.renderfx = other.renderfx
        this.solid = other.solid
        this.sound = other.sound
        this.event = other.event
    }
}

/* ============================================== */

/* player_state_t is the information needed in addition to pmove_state_t
 * to rendered a view.  There will only be 10 player_state_t sent each second,
 * but the number of pmove_state_t changes will be reletive to client
 * frame rates */
export class player_state_t {
	pmove = new pmove_state_t()        /* for prediction */

	viewangles = [0,0,0]          /* for fixed views */
	viewoffset = [0,0,0]          /* add to pmovestate->origin */
	kick_angles = [0,0,0]         /* add to view direction to get render angles */
								/* set by weapon kicks, pain effects, etc */

	gunangles = [0,0,0]
	gunoffset = [0,0,0]
	gunindex: number = 0
	gunframe: number = 0

	blend  = [0,0,0, 0]             /* rgba full screen effect */
	fov: number = 0.0                  /* horizontal field of view */
	rdflags: number = 0                /* refdef flags */

    stats = new Array<number>(MAX_STATS) /* fast status bar updates */

    copy(other: player_state_t) {
        this.pmove.copy(other.pmove)
        for (let i = 0; i < 3; i++) {
            this.viewangles[i] = other.viewangles[i]
            this.viewoffset[i] = other.viewoffset[i]
            this.kick_angles[i] = other.kick_angles[i]
            this.gunangles[i] = other.gunangles[i]
            this.gunoffset[i] = other.gunoffset[i]
        }
        this.gunindex = other.gunindex
        this.gunframe = other.gunframe
        for (let i = 0; i < 4; i++) {
            this.blend[i] = other.blend[i]
        }
        this.fov = other.fov
        this.rdflags = other.rdflags
        for (let i = 0; i < MAX_STATS; i++) {
            this.stats[i] = other.stats[i]
        }
    }
}

function DEG2RAD(a: number): number {
    return (a * Math.PI) / 180.0
} 

export const vec3_origin = [0, 0, 0];

/* ============================================================================ */

export function RotatePointAroundVector(dst: number[], dir: number[],
		point: number[], degrees: number)
{
	// float m[3][3];
	// float im[3][3];
	// float zrot[3][3];
	// float tmpmat[3][3];
	// float rot[3][3];
	// int i;
	// vec3_t vr, vup, vf;

    let vf = [dir[0], dir[1], dir[2]]

    let vr = [0,0,0]
	PerpendicularVector(vr, dir);
    let vup = [0,0,0]
	CrossProduct(vr, vf, vup);

    let m = [
        [0,0,0],
        [0,0,0],
        [0,0,0]
    ]
	m[0][0] = vr[0];
	m[1][0] = vr[1];
	m[2][0] = vr[2];

	m[0][1] = vup[0];
	m[1][1] = vup[1];
	m[2][1] = vup[2];

	m[0][2] = vf[0];
	m[1][2] = vf[1];
	m[2][2] = vf[2];

    let im = [
        [0,0,0],
        [0,0,0],
        [0,0,0]
    ]
    for (let i = 0; i < 3; i++) {
        for (let j = 0; j < 3; j++)
            im[i][j] = m[i][j]
    }

	im[0][1] = m[1][0];
	im[0][2] = m[2][0];
	im[1][0] = m[0][1];
	im[1][2] = m[2][1];
	im[2][0] = m[0][2];
	im[2][1] = m[1][2];

    let zrot = [
        [0,0,0],
        [0,0,0],
        [0,0,0]
    ]
	zrot[2][2] = 1.0;

	zrot[0][0] = Math.cos(DEG2RAD(degrees));
	zrot[0][1] = Math.sin(DEG2RAD(degrees));
	zrot[1][0] = -Math.sin(DEG2RAD(degrees));
	zrot[1][1] = Math.cos(DEG2RAD(degrees));

    let tmpmat = [
        [0,0,0],
        [0,0,0],
        [0,0,0]
    ]
    let rot = [
        [0,0,0],
        [0,0,0],
        [0,0,0]
    ]
	R_ConcatRotations(m, zrot, tmpmat);
	R_ConcatRotations(tmpmat, im, rot);

	for (let i = 0; i < 3; i++) {
		dst[i] = rot[i][0] * point[0] + rot[i][1] * point[1] + rot[i][2] *
				 point[2];
	}
}

export function ProjectPointOnPlane(dst: number[], p: number[], normal: number[]) {

	let inv_denom = 1.0 / DotProduct(normal, normal);

	let d = DotProduct(normal, p) * inv_denom;

	let n = [ normal[0] * inv_denom, normal[1] * inv_denom, normal[2] * inv_denom ]

	dst[0] = p[0] - d * n[0];
	dst[1] = p[1] - d * n[1];
	dst[2] = p[2] - d * n[2];
}


/* assumes "src" is normalized */
export function PerpendicularVector(dst: number[], src: number[]) {

	/* find the smallest magnitude axially aligned vector */
    let pos = 0
    let minelem = 1.0
	for (let i = 0; i < 3; i++) {
		if (Math.abs(src[i]) < minelem) {
			pos = i;
			minelem = Math.abs(src[i]);
		}
	}

	let tempvec = [0,0,0]
	tempvec[pos] = 1.0;

	/* project the point onto the plane defined by src */
	ProjectPointOnPlane(dst, tempvec, src);

	/* normalize the result */
	VectorNormalize(dst);
}

export function R_ConcatRotations(in1: number[][], in2: number[][], out: number[][])
{
	out[0][0] = in1[0][0] * in2[0][0] + in1[0][1] * in2[1][0] +
				in1[0][2] * in2[2][0];
	out[0][1] = in1[0][0] * in2[0][1] + in1[0][1] * in2[1][1] +
				in1[0][2] * in2[2][1];
	out[0][2] = in1[0][0] * in2[0][2] + in1[0][1] * in2[1][2] +
				in1[0][2] * in2[2][2];
	out[1][0] = in1[1][0] * in2[0][0] + in1[1][1] * in2[1][0] +
				in1[1][2] * in2[2][0];
	out[1][1] = in1[1][0] * in2[0][1] + in1[1][1] * in2[1][1] +
				in1[1][2] * in2[2][1];
	out[1][2] = in1[1][0] * in2[0][2] + in1[1][1] * in2[1][2] +
				in1[1][2] * in2[2][2];
	out[2][0] = in1[2][0] * in2[0][0] + in1[2][1] * in2[1][0] +
				in1[2][2] * in2[2][0];
	out[2][1] = in1[2][0] * in2[0][1] + in1[2][1] * in2[1][1] +
				in1[2][2] * in2[2][1];
	out[2][2] = in1[2][0] * in2[0][2] + in1[2][1] * in2[1][2] +
				in1[2][2] * in2[2][2];
}

export function R_ConcatTransforms(in1: number[][], in2: number[][], out: number[][])
{
	out[0][0] = in1[0][0] * in2[0][0] + in1[0][1] * in2[1][0] +
				in1[0][2] * in2[2][0];
	out[0][1] = in1[0][0] * in2[0][1] + in1[0][1] * in2[1][1] +
				in1[0][2] * in2[2][1];
	out[0][2] = in1[0][0] * in2[0][2] + in1[0][1] * in2[1][2] +
				in1[0][2] * in2[2][2];
	out[0][3] = in1[0][0] * in2[0][3] + in1[0][1] * in2[1][3] +
				in1[0][2] * in2[2][3] + in1[0][3];
	out[1][0] = in1[1][0] * in2[0][0] + in1[1][1] * in2[1][0] +
				in1[1][2] * in2[2][0];
	out[1][1] = in1[1][0] * in2[0][1] + in1[1][1] * in2[1][1] +
				in1[1][2] * in2[2][1];
	out[1][2] = in1[1][0] * in2[0][2] + in1[1][1] * in2[1][2] +
				in1[1][2] * in2[2][2];
	out[1][3] = in1[1][0] * in2[0][3] + in1[1][1] * in2[1][3] +
				in1[1][2] * in2[2][3] + in1[1][3];
	out[2][0] = in1[2][0] * in2[0][0] + in1[2][1] * in2[1][0] +
				in1[2][2] * in2[2][0];
	out[2][1] = in1[2][0] * in2[0][1] + in1[2][1] * in2[1][1] +
				in1[2][2] * in2[2][1];
	out[2][2] = in1[2][0] * in2[0][2] + in1[2][1] * in2[1][2] +
				in1[2][2] * in2[2][2];
	out[2][3] = in1[2][0] * in2[0][3] + in1[2][1] * in2[1][3] +
				in1[2][2] * in2[2][3] + in1[2][3];
}


export function LerpAngle(a2: number, a1: number, frac: number): number {
	if (a1 - a2 > 180) {
		a1 -= 360;
	}

	if (a1 - a2 < -180) {
		a1 += 360;
	}

	return a2 + frac * (a1 - a2);
}

/*
 * Returns 1, 2, or 1 + 2
 */
export function BoxOnPlaneSide(emins: number[], emaxs: number[],p: cplane_t): number {

	/* fast axial cases */
	if (p.type < 3) {
		if (p.dist <= emins[p.type]) {
			return 1;
		}

		if (p.dist >= emaxs[p.type]) {
			return 2;
		}

		return 3;
	}

	/* general case */
    let dist1: number
    let dist2: number
	switch (p.signbits) {
		case 0:
			dist1 = p.normal[0] * emaxs[0] + p.normal[1] * emaxs[1] +
					p.normal[2] * emaxs[2];
			dist2 = p.normal[0] * emins[0] + p.normal[1] * emins[1] +
					p.normal[2] * emins[2];
			break;
		case 1:
			dist1 = p.normal[0] * emins[0] + p.normal[1] * emaxs[1] +
					p.normal[2] * emaxs[2];
			dist2 = p.normal[0] * emaxs[0] + p.normal[1] * emins[1] +
					p.normal[2] * emins[2];
			break;
		case 2:
			dist1 = p.normal[0] * emaxs[0] + p.normal[1] * emins[1] +
					p.normal[2] * emaxs[2];
			dist2 = p.normal[0] * emins[0] + p.normal[1] * emaxs[1] +
					p.normal[2] * emins[2];
			break;
		case 3:
			dist1 = p.normal[0] * emins[0] + p.normal[1] * emins[1] +
					p.normal[2] * emaxs[2];
			dist2 = p.normal[0] * emaxs[0] + p.normal[1] * emaxs[1] +
					p.normal[2] * emins[2];
			break;
		case 4:
			dist1 = p.normal[0] * emaxs[0] + p.normal[1] * emaxs[1] +
					p.normal[2] * emins[2];
			dist2 = p.normal[0] * emins[0] + p.normal[1] * emins[1] +
					p.normal[2] * emaxs[2];
			break;
		case 5:
			dist1 = p.normal[0] * emins[0] + p.normal[1] * emaxs[1] +
					p.normal[2] * emins[2];
			dist2 = p.normal[0] * emaxs[0] + p.normal[1] * emins[1] +
					p.normal[2] * emaxs[2];
			break;
		case 6:
			dist1 = p.normal[0] * emaxs[0] + p.normal[1] * emins[1] +
					p.normal[2] * emins[2];
			dist2 = p.normal[0] * emins[0] + p.normal[1] * emaxs[1] +
					p.normal[2] * emaxs[2];
			break;
		case 7:
			dist1 = p.normal[0] * emins[0] + p.normal[1] * emins[1] +
					p.normal[2] * emins[2];
			dist2 = p.normal[0] * emaxs[0] + p.normal[1] * emaxs[1] +
					p.normal[2] * emaxs[2];
			break;
		default:
			dist1 = dist2 = 0;
			break;
	}

	let sides = 0;

	if (dist1 >= p.dist) {
		sides = 1;
	}

	if (dist2 < p.dist) {
		sides |= 2;
	}

	return sides;
}



export function AngleVectors(angles: number[], forward: number[], right: number[], up: number[]) {
	// float angle;
	// static float sr, sp, sy, cr, cp, cy;

	let angle = angles[YAW] * (Math.PI * 2 / 360);
	let sy = Math.sin(angle);
	let cy = Math.cos(angle);
	angle = angles[PITCH] * (Math.PI * 2 / 360);
	let sp = Math.sin(angle);
	let cp = Math.cos(angle);
	angle = angles[ROLL] * (Math.PI * 2 / 360);
	let sr = Math.sin(angle);
	let cr = Math.cos(angle);

	if (forward != null)
	{
		forward[0] = cp * cy;
		forward[1] = cp * sy;
		forward[2] = -sp;
	}

	if (right != null)
	{
		right[0] = (-1 * sr * sp * cy + - 1 * cr * -sy);
		right[1] = (-1 * sr * sp * sy + - 1 * cr * cy);
		right[2] = -1 * sr * cp;
	}

	if (up != null)
	{
		up[0] = (cr * sp * cy + - sr * -sy);
		up[1] = (cr * sp * sy + - sr * cy);
		up[2] = cr * cp;
	}
}

export function VectorMA(veca: number[], scale: number, vecb: number[], vecc: number[])
{
	vecc[0] = veca[0] + scale * vecb[0];
	vecc[1] = veca[1] + scale * vecb[1];
	vecc[2] = veca[2] + scale * vecb[2];
}

export function DotProduct(v1: number[], v2: number[]): number {
	return v1[0] * v2[0] + v1[1] * v2[1] + v1[2] * v2[2];
}

export function VectorNormalize(v: number[]): number {

	let length = v[0] * v[0] + v[1] * v[1] + v[2] * v[2];
	length = Math.sqrt(length);

	if (length) {
		let ilength = 1 / length;
		v[0] *= ilength;
		v[1] *= ilength;
		v[2] *= ilength;
	}

	return length;
}

export function VectorScale(ind: number[], scale: number, out: number[]) {
	out[0] = ind[0] * scale;
	out[1] = ind[1] * scale;
	out[2] = ind[2] * scale;
}


export function VectorAdd(veca: number[], vecb: number[], out: number[]) {
	out[0] = veca[0] + vecb[0];
	out[1] = veca[1] + vecb[1];
	out[2] = veca[2] + vecb[2];
}

export function VectorSubtract(veca: number[], vecb: number[], out: number[]) {
	out[0] = veca[0] - vecb[0];
	out[1] = veca[1] - vecb[1];
	out[2] = veca[2] - vecb[2];
}

export function VectorCopy(from: number[], to: number[]) {
	for (let i = 0; i < 3; i++) {
		to[i] = from[i]
	}
}

export function CrossProduct(v1: number[], v2: number[], cross: number[]) {
	cross[0] = v1[1] * v2[2] - v1[2] * v2[1];
	cross[1] = v1[2] * v2[0] - v1[0] * v2[2];
	cross[2] = v1[0] * v2[1] - v1[1] * v2[0];
}

export function VectorLength(v: number[]): number {

	let length = 0;

	for (let i = 0; i < 3; i++) {
		length += v[i] * v[i];
	}

	length = Math.sqrt(length);

	return length;
}


interface COM_Parse_Result {
    token: string
    index: number
}

/*
 * Parse a token out of a string
 */
export function COM_Parse(data: string, index: number): COM_Parse_Result {
	// int c;
	// int len;
	// char *data;

	// data = *data_p;
	// len = 0;
	// com_token[0] = 0;
    let token = ""

	if (!data || index < 0 || index >= data.length) {
		return { token: "", index: -1 }
	}

    let skipwhite = true
    while (skipwhite) {
        skipwhite = false;

        while (index < data.length && data[index] <= ' ') {
            index++
        }
        if (index >= data.length) {
            return { token: "", index: -1 }
        }

        /* skip // comments */
        if (index + 1 < data.length && (data[index] == '/') && (data[index + 1] == '/')) {
            while (index < data.length && data[index] != '\n') {
                index++;
            }
            skipwhite = true
        }
    }

	/* handle quoted strings specially */
	if (data[index] == '\"') {
		index++;

		while (true) {
            if (index >= data.length) {
                return { token: token, index: index }
            }
			let c = data[index++]

			if (c == '\"') {
				return { token: token, index: index }
			}

            token += c;
		}
	}

	/* parse a regular word */
	while (true) {
        if (index >= data.length) {
            return { token: token, index: index }
        }
        token += data[index++]
        if (index >= data.length || data[index] <= ' ') {
            return { token: token, index: index }
        }
	}
}

/* 
 * Generate a pseudorandom 
 * integer >0. 
 */
export function randk(): number {
	return ~~(Math.random() * 32768);
}

/*
 * Generate a pseudorandom
 * signed float between 
 * 0 and 1.
 */
export function frandk() {
	return Math.random()
}

/* Generate a pseudorandom
 * float between -1 and 1.
 */
export function crandk()
{
	return (Math.random() * 2.0) - 1.0;
}
